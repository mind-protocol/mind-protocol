<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Protocol - Consciousness Substrate Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #e8e8e8;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(20, 20, 24, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 24px;
        }

        h1 {
            font-size: 18px;
            font-weight: 600;
            color: #5efc82;
            margin: 0;
            letter-spacing: -0.5px;
            text-shadow: 0 0 20px rgba(94, 252, 130, 0.3);
        }

        .selector-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .selector-group label {
            font-size: 13px;
            font-weight: 500;
            color: #a0a0a0;
        }

        select, button {
            background: rgba(40, 40, 44, 0.8);
            color: #e8e8e8;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 14px;
            font-size: 13px;
            font-family: inherit;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        select:hover, button:hover {
            border-color: rgba(94, 252, 130, 0.5);
            background: rgba(50, 50, 54, 0.9);
            box-shadow: 0 0 15px rgba(94, 252, 130, 0.1);
        }

        button:active {
            transform: scale(0.98);
        }

        .status {
            margin-left: auto;
            font-size: 11px;
            color: #666;
        }

        .status.connected {
            color: #4CAF50;
        }

        .status.disconnected {
            color: #f44336;
        }

        #controls {
            position: fixed;
            top: 80px;
            left: 24px;
            background: rgba(20, 20, 24, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 900;
            max-width: 320px;
        }

        .control-section {
            margin-bottom: 15px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-section h3 {
            font-size: 12px;
            font-weight: 600;
            color: #5efc82;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
        }

        .slider-value {
            font-size: 11px;
            color: #aaa;
            min-width: 60px;
            text-align: right;
        }

        input[type="checkbox"] {
            margin-right: 6px;
        }

        .checkbox-label {
            font-size: 13px;
            color: #d0d0d0;
            cursor: pointer;
            user-select: none;
        }

        .checkbox-label:hover {
            color: #e8e8e8;
        }

        #graph-container {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 100%);
        }

        #graph {
            width: 100%;
            height: 100%;
        }

        /* SVG filters for glow effects */
        .link-active {
            stroke: #5efc82 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 6px #5efc82);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(20, 20, 24, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(94, 252, 130, 0.2);
            padding: 14px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 2000;
            max-width: 350px;
            display: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .tooltip-title {
            font-weight: 600;
            color: #5efc82;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .tooltip-row {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .tooltip-label {
            color: #888;
        }

        .tooltip-value {
            color: #e0e0e0;
        }

        /* Stats panel */
        #stats {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(20, 20, 24, 0.95);
            backdrop-filter: blur(20px);
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 12px;
            color: #a0a0a0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .stat-row {
            margin: 3px 0;
        }

        .stat-value {
            color: #4CAF50;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <!-- Header with graph selector -->
    <div id="header">
        <h1>Mind Protocol - Consciousness Substrate</h1>

        <div class="selector-group">
            <label>Graph Type:</label>
            <select id="graphType">
                <option value="citizen">Citizen (N1)</option>
                <option value="organization">Organization (N2)</option>
                <option value="ecosystem">Ecosystem (N3)</option>
            </select>
        </div>

        <div class="selector-group">
            <label>Graph ID:</label>
            <select id="graphId">
                <option value="">Loading...</option>
            </select>
        </div>

        <div class="selector-group">
            <label>Entity View:</label>
            <select id="entityView">
                <option value="structural">Structural (type-based)</option>
                <option value="">Loading entities...</option>
            </select>
        </div>

        <div class="status disconnected" id="status">Select a graph</div>
    </div>

    <!-- Time controls -->
    <div id="controls">
        <div class="control-section">
            <h3>Time Range</h3>
            <div class="slider-container">
                <input type="range" id="timeRange" min="60000" max="86400000" step="60000" value="3600000">
                <span class="slider-value" id="timeRangeValue">1 hour</span>
            </div>
        </div>

        <div class="control-section">
            <h3>Filters</h3>
            <label class="checkbox-label">
                <input type="checkbox" id="showRecentOnly" checked>
                Show only recent activity
            </label>
        </div>

        <div class="control-section">
            <h3>Display</h3>
            <label class="checkbox-label">
                <input type="checkbox" id="showLabels" checked>
                Show node labels
            </label>
        </div>

        <div class="control-section">
            <h3>Search</h3>
            <input
                type="text"
                id="searchBox"
                placeholder="Search nodes..."
                style="width: 100%; padding: 6px; background: #2a2a2a;
                       border: 1px solid #444; color: #e0e0e0; font-size: 12px; border-radius: 3px;">
            <div id="searchResults" style="max-height: 150px; overflow-y: auto;
                                          margin-top: 8px; font-size: 11px;"></div>
        </div>

        <div class="control-section" id="valence-legend" style="display: none;">
            <h3>Valence Color Scale</h3>
            <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                Link colors in entity view:
            </div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 3px; background: #ef4444;"></div>
                    <span style="font-size: 11px; color: #d0d0d0;">Negative (-1.0) - Avoidance</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 3px; background: #94a3b8;"></div>
                    <span style="font-size: 11px; color: #d0d0d0;">Neutral (0.0)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 3px; background: #22c55e;"></div>
                    <span style="font-size: 11px; color: #d0d0d0;">Positive (+1.0) - Approach</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph visualization -->
    <div id="graph-container">
        <svg id="graph"></svg>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Stats -->
    <div id="stats">
        <div class="stat-row">Nodes: <span class="stat-value" id="nodeCount">0</span></div>
        <div class="stat-row">Links: <span class="stat-value" id="linkCount">0</span></div>
        <div class="stat-row">Active Nodes: <span class="stat-value" id="activeNodeCount">0</span></div>
        <div class="stat-row">Operations/sec: <span class="stat-value" id="opsPerSec">0</span></div>
    </div>

    <!-- Detail Panel -->
    <div id="detail-panel" style="
        position: fixed;
        right: 24px;
        top: 80px;
        width: 380px;
        max-height: calc(100vh - 120px);
        background: rgba(20, 20, 24, 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        display: none;
        overflow-y: auto;
        z-index: 1000;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    ">
        <div id="detail-content"></div>
    </div>

    <script>
        // ====================================================================
        // State
        // ====================================================================

        let ws = null;
        let currentGraphType = 'citizen';
        let currentGraphId = null;
        let availableGraphs = {};

        let nodes = [];
        let links = [];
        let entities = [];

        let currentTime = Date.now();
        let timeRange = 3600000; // 1 hour default
        let showRecentOnly = false;  // Show all nodes by default
        let showLabels = true;

        let operationCount = 0;
        let lastOperationTime = Date.now();

        let selectedNode = null;
        let selectedEntity = 'structural';  // 'structural' or entity_id for per-entity view

        // Node type colors - from UNIFIED_SCHEMA_REFERENCE.md
        const NODE_TYPE_COLORS = {
            // N1 Personal (11 types) - Warm, emotional colors
            'Memory': '#14b8a6',              // Teal - episodic memories
            'Conversation': '#06b6d4',        // Cyan - dialogues
            'Person': '#8b5cf6',              // Violet - relationships
            'Relationship': '#a855f7',        // Purple - connections
            'Personal_Goal': '#f59e0b',       // Amber - aspirations
            'Personal_Value': '#fbbf24',      // Yellow - core values
            'Personal_Pattern': '#ec4899',    // Pink - habits
            'Realization': '#5efc82',         // Bright green - insights
            'Wound': '#ef4444',               // Red - trauma
            'Coping_Mechanism': '#f97316',    // Orange - defenses
            'Trigger': '#dc2626',             // Dark red - activators

            // N2 Organizational (13 types) - Professional, structured
            'Human': '#3b82f6',               // Blue - human members
            'AI_Agent': '#6366f1',            // Indigo - AI members
            'Team': '#8b5cf6',                // Violet - groups
            'Department': '#7c3aed',          // Purple - org structure
            'Decision': '#22c55e',            // Green - choices
            'Project': '#10b981',             // Emerald - initiatives
            'Task': '#f59e0b',                // Amber - work items
            'Milestone': '#fbbf24',           // Yellow - achievements
            'Best_Practice': '#5efc82',       // Bright green - proven patterns
            'Anti_Pattern': '#ef4444',        // Red - failures
            'Risk': '#dc2626',                // Dark red - threats
            'Metric': '#06b6d4',              // Cyan - measurements
            'Process': '#64748b',             // Gray - workflows

            // N2/N3 Conceptual (5 types) - Abstract, knowledge
            'Concept': '#06b6d4',             // Cyan - ideas
            'Principle': '#5efc82',           // Bright green - foundations
            'Mechanism': '#10b981',           // Emerald - systems
            'Document': '#94a3b8',            // Light gray - artifacts
            'Documentation': '#cbd5e1',       // Very light gray - docs

            // N3 Ecosystem (15 types) - External, evidence-based
            'Company': '#3b82f6',             // Blue - organizations
            'External_Person': '#8b5cf6',     // Violet - individuals
            'Wallet_Address': '#fbbf24',      // Yellow - blockchain
            'Social_Media_Account': '#06b6d4',// Cyan - social
            'Smart_Contract': '#22c55e',      // Green - code
            'Post': '#ec4899',                // Pink - content
            'Transaction': '#f59e0b',         // Amber - transfers
            'Deal': '#10b981',                // Emerald - partnerships
            'Event': '#ef4444',               // Red - temporal
            'Market_Signal': '#14b8a6',       // Teal - indicators
            'Psychological_Trait': '#a855f7', // Purple - behavior
            'Behavioral_Pattern': '#ec4899',  // Pink - patterns
            'Reputation_Assessment': '#fbbf24', // Yellow - reputation
            'Network_Cluster': '#6366f1',     // Indigo - groups
            'Integration': '#22c55e',         // Green - connections

            // Fallback
            'Node': '#64748b',                // Gray - generic
            'default': '#64748b'
        };

        // Node type emojis - instant visual recognition
        const NODE_TYPE_EMOJIS = {
            // N1 Personal
            'Memory': 'üí≠',
            'Conversation': 'üí¨',
            'Person': 'üë§',
            'Relationship': 'ü§ù',
            'Personal_Goal': 'üéØ',
            'Personal_Value': 'üíé',
            'Personal_Pattern': 'üîÑ',
            'Realization': 'üí°',
            'Wound': 'ü©π',
            'Coping_Mechanism': 'üõ°Ô∏è',
            'Trigger': '‚ö°',

            // N2 Organizational
            'Human': 'üë®‚Äçüíº',
            'AI_Agent': 'ü§ñ',
            'Team': 'üë•',
            'Department': 'üè¢',
            'Decision': '‚öñÔ∏è',
            'Project': 'üìã',
            'Task': '‚úÖ',
            'Milestone': 'üèÅ',
            'Best_Practice': '‚≠ê',
            'Anti_Pattern': '‚ö†Ô∏è',
            'Risk': 'üö®',
            'Metric': 'üìä',
            'Process': '‚öôÔ∏è',

            // N2/N3 Conceptual
            'Concept': 'üß©',
            'Principle': 'üìú',
            'Mechanism': 'üîß',
            'Document': 'üìÑ',
            'Documentation': 'üìñ',

            // N3 Ecosystem
            'Company': 'üèõÔ∏è',
            'External_Person': 'üßë',
            'Wallet_Address': 'üí∞',
            'Social_Media_Account': 'üì±',
            'Smart_Contract': 'üìù',
            'Post': 'üì¢',
            'Transaction': 'üí∏',
            'Deal': 'ü§ù',
            'Event': 'üìÖ',
            'Market_Signal': 'üìà',
            'Psychological_Trait': 'üß†',
            'Behavioral_Pattern': 'üîÅ',
            'Reputation_Assessment': '‚öñÔ∏è',
            'Network_Cluster': 'üï∏Ô∏è',
            'Integration': 'üîó',

            // Fallback
            'Node': '‚ö™',
            'default': '‚ö™'
        };

        // Link type colors - semantic relationship encoding
        const LINK_TYPE_COLORS = {
            'JUSTIFIES': '#ef4444',        // Red - foundational reasoning
            'BUILDS_TOWARD': '#3b82f6',    // Blue - construction
            'ENABLES': '#22c55e',          // Green - capabilities
            'USES': '#8b5cf6',             // Purple - dependencies
            'RELATES_TO': '#64748b',       // Gray - associations
            'EXEMPLIFIES': '#f59e0b',      // Yellow - examples
            'GROUNDS': '#dc2626',          // Dark red - grounding
            'VALIDATES': '#16a34a',        // Dark green - validation
            'REQUIRES': '#0ea5e9',         // Cyan - requirements
            'INTEGRATES': '#6366f1',       // Indigo - integration
            'GUIDES': '#f97316',           // Orange - guidance
            'IMPLEMENTS': '#8b5cf6',       // Purple - implementation
            'DEMONSTRATES': '#a855f7'      // Pink - demonstration
        };

        // Valence color scale: negative (red) ‚Üí neutral (gray) ‚Üí positive (green)
        function getValenceColor(valence) {
            // valence: -1.0 to +1.0
            if (valence === null || valence === undefined) {
                return '#64748b';  // Gray - no valence data
            }

            // Normalize to 0-1 range
            const normalized = (valence + 1.0) / 2.0;

            if (normalized < 0.5) {
                // Negative: red to gray
                const t = normalized * 2;  // 0 to 1
                return d3.interpolateRgb('#ef4444', '#94a3b8')(t);
            } else {
                // Positive: gray to green
                const t = (normalized - 0.5) * 2;  // 0 to 1
                return d3.interpolateRgb('#94a3b8', '#22c55e')(t);
            }
        }

        function getLinkColor(link) {
            if (selectedEntity === 'structural') {
                // Structural mode: color by link type
                return LINK_TYPE_COLORS[link.type] || '#666';
            } else {
                // Entity mode: color by valence
                const valences = link.sub_entity_valences || {};
                const valence = valences[selectedEntity];
                return getValenceColor(valence);
            }
        }

        // ====================================================================
        // Graph Discovery
        // ====================================================================

        async function fetchAvailableGraphs() {
            try {
                const response = await fetch('/api/graphs');
                availableGraphs = await response.json();
                updateGraphSelector();
            } catch (error) {
                console.error('Error fetching graphs:', error);
            }
        }

        function updateGraphSelector() {
            const graphType = document.getElementById('graphType').value;
            const graphIdSelect = document.getElementById('graphId');

            // Clear current options
            graphIdSelect.innerHTML = '';

            // Get graphs for selected type
            const graphs = availableGraphs[graphType + 's'] || [];

            if (graphs.length === 0) {
                graphIdSelect.innerHTML = '<option value="">No graphs found</option>';
                return;
            }

            // Add options
            graphs.forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = id;
                graphIdSelect.appendChild(option);
            });

            // Auto-select first and auto-connect
            if (graphs.length > 0) {
                graphIdSelect.value = graphs[0];
                currentGraphId = graphs[0];
                connectToGraph();  // Auto-connect when graph type changes
            }
        }

        // ====================================================================
        // WebSocket Connection
        // ====================================================================

        function connectToGraph() {
            const graphType = document.getElementById('graphType').value;
            const graphId = document.getElementById('graphId').value;

            if (!graphId) {
                console.error('No graph ID selected');
                return;
            }

            // Close existing connection
            if (ws) {
                ws.close();
            }

            currentGraphType = graphType;
            currentGraphId = graphId;

            // Connect to WebSocket
            const wsUrl = `ws://${window.location.host}/ws/graph/${graphType}/${graphId}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('Connected to', graphType, graphId);
                document.getElementById('status').textContent = `Connected: ${graphType}/${graphId}`;
                document.getElementById('status').className = 'status connected';
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('status').textContent = 'Error';
                document.getElementById('status').className = 'status disconnected';
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                document.getElementById('status').textContent = 'Disconnected';
                document.getElementById('status').className = 'status disconnected';
            };
        }

        function handleMessage(message) {
            currentTime = Date.now();

            if (message.type === 'initial_state') {
                // Initial load
                nodes = message.data.nodes || [];
                links = message.data.links || [];
                entities = message.data.entities || [];
                updateEntitySelector();
                updateVisualization();
            }
            else if (message.type === 'graph_update') {
                // Incremental update
                applyDiff(message.diff);

                // Animate operations
                if (message.operations && message.operations.length > 0) {
                    message.operations.forEach(op => animateOperation(op));
                    updateOperationStats(message.operations.length);
                }

                updateVisualization();
            }
            else if (message.type === 'error') {
                console.error('Server error:', message.message);
                alert(message.message);
            }
        }

        function updateEntitySelector() {
            const entitySelect = document.getElementById('entityView');

            // Clear current options (except structural)
            entitySelect.innerHTML = '<option value="structural">Structural (type-based)</option>';

            if (entities && entities.length > 0) {
                // Add each SubEntity as an option
                entities.forEach(entity => {
                    const option = document.createElement('option');
                    option.value = entity.entity_id;
                    option.textContent = `${entity.entity_id} (arousal: ${(entity.arousal_level || 0).toFixed(2)})`;
                    entitySelect.appendChild(option);
                });
            } else {
                // Extract unique entity IDs from link valences
                const entityIds = new Set();
                links.forEach(link => {
                    if (link.sub_entity_valences) {
                        Object.keys(link.sub_entity_valences).forEach(id => entityIds.add(id));
                    }
                });

                if (entityIds.size > 0) {
                    entityIds.forEach(id => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = id;
                        entitySelect.appendChild(option);
                    });
                } else {
                    // No entities found
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No entities found';
                    option.disabled = true;
                    entitySelect.appendChild(option);
                }
            }
        }

        function applyDiff(diff) {
            // Add new nodes
            if (diff.nodes_added) {
                nodes.push(...diff.nodes_added);
            }

            // Update existing nodes
            if (diff.nodes_updated) {
                diff.nodes_updated.forEach(updated => {
                    const index = nodes.findIndex(n => n.id === updated.id);
                    if (index !== -1) {
                        nodes[index] = updated;
                    }
                });
            }

            // Similar for links
            if (diff.links_added) {
                links.push(...diff.links_added);
            }

            if (diff.links_updated) {
                diff.links_updated.forEach(updated => {
                    const index = links.findIndex(l => l.id === updated.id);
                    if (index !== -1) {
                        links[index] = updated;
                    }
                });
            }
        }

        // ====================================================================
        // D3 Visualization (2D Topological)
        // ====================================================================

        const width = window.innerWidth;
        const height = window.innerHeight - 70;

        const svg = d3.select("#graph");
        const g = svg.append("g");

        // Define arrow markers for links
        svg.append("defs").selectAll("marker")
            .data(Object.keys(LINK_TYPE_COLORS))
            .join("marker")
            .attr("id", d => `arrow-${d}`)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)  // Position arrow at end of line
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", d => LINK_TYPE_COLORS[d]);

        // Default arrow for unknown types
        svg.select("defs").append("marker")
            .attr("id", "arrow-default")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#666");

        // Valence arrow (color will match link in entity mode)
        svg.select("defs").append("marker")
            .attr("id", "arrow-valence")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#94a3b8");  // Default gray

        // Track mouse position and zoom scale
        let mouseX = width / 2;
        let mouseY = height / 2;
        let currentZoomScale = 1;

        // Zoom behavior
        svg.call(d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
                currentZoomScale = event.transform.k;
                updateLabelVisibility();
            }));

        // Track mouse position
        svg.on("mousemove", (event) => {
            const [x, y] = d3.pointer(event, g.node());
            mouseX = x;
            mouseY = y;
            updateLabelVisibility();
        });

        // Click background to deselect
        svg.on("click", () => {
            selectedNode = null;
            document.getElementById('detail-panel').style.display = 'none';
            clearHighlight();
            // Remove selection glow from all emojis
            if (emojiElements) {
                emojiElements.style("filter", d => {
                    const glow = getNodeGlow(d);
                    if (glow > 0) {
                        return "drop-shadow(0 0 8px #5efc82) drop-shadow(0 0 4px #5efc82)";
                    }
                    return "none";
                });
            }
        });

        // Force simulation (2D only)
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, (height - 70) / 2))
            .force("collision", d3.forceCollide().radius(35));  // Larger radius for bigger emojis

        let linkElements, textElements, emojiElements;  // nodeElements removed - using emojis only

        function updateVisualization() {
            // Apply time filtering
            const { nodes: filteredNodes, links: filteredLinks } = filterByTime();

            // Update link elements
            linkElements = g.selectAll("line")
                .data(filteredLinks, d => d.id)
                .join("line")
                .attr("stroke", d => getLinkColor(d))  // Dynamic: type-based or valence-based
                .attr("stroke-width", d => Math.max(2.5, (d.strength || 0.5) * 6))  // Thicker: 2.5-6px instead of 1-4px
                .attr("stroke-opacity", d => Math.max(0.6, getLinkOpacity(d)))  // More visible: min 0.6 instead of lower
                .attr("marker-end", d => {
                    // Arrow color matches link color in entity mode
                    if (selectedEntity !== 'structural') {
                        return `url(#arrow-valence)`;
                    }
                    return `url(#arrow-${d.type || 'default'})`;
                })
                .style("cursor", "pointer")
                .on("mouseenter", showLinkTooltip)
                .on("mouseleave", hideTooltip);

            // Node circles removed - using emojis only

            // Update emoji labels (now the primary visual element)
            emojiElements = g.selectAll("text.emoji")
                .data(filteredNodes, d => d.id)
                .join("text")
                .attr("class", "emoji")
                .text(d => {
                    const nodeType = (d.labels && d.labels[0]) || 'Node';
                    return NODE_TYPE_EMOJIS[nodeType] || NODE_TYPE_EMOJIS['default'];
                })
                .attr("font-size", d => {
                    const weight = computeNodeWeight(d);
                    return Math.max(24, 16 + weight * 16);  // Size by computed weight
                })
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "central")
                .style("pointer-events", "auto")  // Enable click/hover
                .style("cursor", "pointer")
                .style("user-select", "none")
                .style("filter", d => {
                    // Glow for recently active nodes (SubEntity activity)
                    const glow = getNodeGlow(d);
                    if (glow > 0) {
                        return "drop-shadow(0 0 8px #5efc82) drop-shadow(0 0 4px #5efc82)";
                    }
                    // Selected node gets green outline
                    if (selectedNode && d.id === selectedNode.id) {
                        return "drop-shadow(0 0 6px #4CAF50) drop-shadow(0 0 3px #4CAF50)";
                    }
                    return "none";
                })
                .call(drag(simulation))
                .on("click", (event, d) => {
                    event.stopPropagation();
                    selectNode(d);
                    highlightNeighborhood(d);
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    clearHighlight();
                })
                .on("mouseenter", (event, d) => {
                    showTooltip(event, d);
                    highlightConnectedLinks(d);
                })
                .on("mouseleave", (event, d) => {
                    hideTooltip(event, d);
                    unhighlightConnectedLinks();
                });

            // Update text labels (multi-line wrapping)
            if (showLabels) {
                // Sort nodes by weight (smaller weight first, larger on top)
                const sortedNodes = [...filteredNodes].sort((a, b) =>
                    computeNodeWeight(a) - computeNodeWeight(b)
                );

                // Helper: Split text into lines at spaces, underscores, hyphens
                function wrapText(text, maxCharsPerLine = 20) {
                    if (!text) return [''];

                    const words = text.split(/(\s+|_|-)/);  // Split but keep separators
                    const lines = [];
                    let currentLine = '';

                    for (let word of words) {
                        if ((currentLine + word).length > maxCharsPerLine && currentLine.length > 0) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine += word;
                        }
                    }

                    if (currentLine) lines.push(currentLine);

                    return lines.slice(0, 3);  // Max 3 lines
                }

                // Create label groups
                const labelGroups = g.selectAll("g.label-group")
                    .data(sortedNodes, d => d.id)
                    .join("g")
                    .attr("class", "label-group")
                    .style("pointer-events", "none")
                    .style("opacity", 0);  // Initially hidden

                // Text labels with tspan for each line
                labelGroups.each(function(d) {
                    const group = d3.select(this);
                    const lines = wrapText(d.text, 20);

                    // Remove old text
                    group.selectAll("text").remove();

                    // Create new text with tspans (zoom-independent sizing)
                    const baseFontSize = 13;
                    const text = group.append("text")
                        .attr("class", "label")
                        .attr("x", 18)
                        .attr("y", 0)
                        .attr("font-size", baseFontSize)
                        .attr("font-weight", 500)
                        .attr("fill", "#e8e8e8")
                        .style("text-shadow", "0 2px 8px rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 1)")
                        .attr("transform", `scale(${1 / currentZoomScale})`);  // Zoom-independent

                    lines.forEach((line, i) => {
                        text.append("tspan")
                            .attr("x", 18)
                            .attr("dy", i === 0 ? "-0.6em" : "1.1em")
                            .text(line);
                    });
                });
            } else {
                g.selectAll("g.label-group").remove();
            }

            // Update simulation
            simulation.nodes(filteredNodes).on("tick", ticked);
            simulation.force("link").links(filteredLinks);
            simulation.alpha(0.3).restart();

            // Update stats
            updateStats(filteredNodes, filteredLinks);

            // Update label visibility after everything is rendered
            setTimeout(updateLabelVisibility, 0);
        }

        function updateLabelVisibility() {
            if (!showLabels) return;

            const PROXIMITY_THRESHOLD = 150;  // Show labels within 150px (3x original)
            const labelGroups = g.selectAll("g.label-group");

            labelGroups.each(function(d) {
                if (!d.x || !d.y) return;  // Skip if position not set yet

                // Calculate distance from mouse to node
                const dx = d.x - mouseX;
                const dy = d.y - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Show/hide based on proximity
                const isNear = distance < PROXIMITY_THRESHOLD;
                d3.select(this).style("opacity", isNear ? 1 : 0);

                // Update zoom-independent scaling on text elements
                d3.select(this).selectAll("text")
                    .attr("transform", `scale(${1 / currentZoomScale})`);
            });
        }

        function filterByTime() {
            const cutoffTime = currentTime - timeRange;

            if (showRecentOnly) {
                const activeNodes = nodes.filter(n =>
                    n.last_active && n.last_active > cutoffTime
                );

                const activeNodeIds = new Set(activeNodes.map(n => n.id));
                const activeLinks = links.filter(l =>
                    activeNodeIds.has(l.source.id || l.source) &&
                    activeNodeIds.has(l.target.id || l.target)
                );

                return { nodes: activeNodes, links: activeLinks };
            }

            return { nodes, links };
        }

        function getNodeColor(node) {
            // Color by arousal (emotional/motivational intensity)
            // Emoji shows type, color shows intensity
            const arousal = node.arousal || 0;

            // Cool to warm gradient: blue (dormant) ‚Üí cyan ‚Üí white ‚Üí orange ‚Üí red (intense)
            if (arousal < 0.2) return '#3b82f6';      // Blue - dormant
            if (arousal < 0.4) return '#06b6d4';      // Cyan - low
            if (arousal < 0.6) return '#94a3b8';      // Light gray - moderate
            if (arousal < 0.8) return '#f59e0b';      // Amber - elevated
            return '#ef4444';                         // Red - intense
        }

        function computeNodeWeight(node) {
            // Composite importance metric
            const arousal = node.arousal || 0;
            const confidence = node.confidence || 0.5;
            const traversalCount = node.traversal_count || 0;

            // Normalize traversal count (log scale for large values)
            const normalizedTraversals = Math.min(1.0, Math.log10(traversalCount + 1) / 2);

            // Weight formula: arousal (40%) + confidence (30%) + usage (30%)
            const weight = (arousal * 0.4) + (confidence * 0.3) + (normalizedTraversals * 0.3);

            return weight;
        }

        function getNodeOpacity(node) {
            // Opacity now encodes arousal (motivation/emotional weight)
            const arousal = node.arousal || 0;
            return 0.5 + (arousal * 0.5);  // Range: 0.5-1.0
        }

        function getNodeGlow(node) {
            if (!node.last_active) return 0;

            const age = currentTime - node.last_active;
            const glowWindow = 5000; // 5 seconds

            if (age < glowWindow) {
                return (glowWindow - age) / glowWindow;
            }
            return 0;
        }

        function getLinkOpacity(link) {
            if (!link.last_traversed) return 0.3;

            const age = currentTime - link.last_traversed;
            return Math.max(0.2, 1 - (age / timeRange));
        }

        function selectNode(node) {
            selectedNode = node;

            // Update glow on selected emoji (handled by filter in updateVisualization)
            if (emojiElements) {
                emojiElements.style("filter", d => {
                    // Glow for recently active nodes (SubEntity activity)
                    const glow = getNodeGlow(d);
                    if (glow > 0) {
                        return "drop-shadow(0 0 8px #5efc82) drop-shadow(0 0 4px #5efc82)";
                    }
                    // Selected node gets green outline
                    if (d.id === node.id) {
                        return "drop-shadow(0 0 6px #4CAF50) drop-shadow(0 0 3px #4CAF50)";
                    }
                    return "none";
                });
            }

            // Show detail panel
            const panel = document.getElementById('detail-panel');
            const content = document.getElementById('detail-content');

            // Get connections
            const inLinks = links.filter(l => (l.target.id || l.target) === node.id);
            const outLinks = links.filter(l => (l.source.id || l.source) === node.id);

            const nodeType = (node.labels && node.labels[0]) || 'Node';
            const nodeEmoji = NODE_TYPE_EMOJIS[nodeType] || NODE_TYPE_EMOJIS['default'];
            const computedWeight = computeNodeWeight(node);
            const arousalColor = getNodeColor(node);

            content.innerHTML = `
                <h3 style="color: #4CAF50; margin-bottom: 10px;">Node Details</h3>

                <div style="margin-bottom: 15px;">
                    <span style="font-size: 32px; margin-right: 12px;">${nodeEmoji}</span>
                    <strong>Type:</strong> ${nodeType}
                </div>

                <div style="margin-bottom: 15px;">
                    <strong>Text:</strong><br/>
                    <span style="color: #e0e0e0;">${node.text || 'No text'}</span>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <strong>Weight:</strong> ${computedWeight.toFixed(2)}
                    </div>
                    <div>
                        <strong>Arousal:</strong> ${(node.arousal || 0).toFixed(2)}
                    </div>
                    <div>
                        <strong>Confidence:</strong> ${(node.confidence || 0).toFixed(2)}
                    </div>
                    <div>
                        <strong>Traversals:</strong> ${node.traversal_count || 0}
                    </div>
                    <div>
                        <strong>Last Entity:</strong> ${node.last_entity || 'None'}
                    </div>
                </div>

                <div style="margin-bottom: 10px;">
                    <strong>Incoming (${inLinks.length}):</strong>
                    ${inLinks.map(l => {
                        const sourceNode = nodes.find(n => n.id === (l.source.id || l.source));
                        const linkColor = LINK_TYPE_COLORS[l.type] || '#666';
                        return `<div style="font-size: 11px; color: #888; margin: 5px 0;">
                            ‚Üê <span style="color: ${linkColor};">[${l.type}]</span> ${(sourceNode?.text || '').substring(0, 40)}
                        </div>`;
                    }).join('')}
                </div>

                <div>
                    <strong>Outgoing (${outLinks.length}):</strong>
                    ${outLinks.map(l => {
                        const targetNode = nodes.find(n => n.id === (l.target.id || l.target));
                        const linkColor = LINK_TYPE_COLORS[l.type] || '#666';
                        return `<div style="font-size: 11px; color: #888; margin: 5px 0;">
                            ‚Üí <span style="color: ${linkColor};">[${l.type}]</span> ${(targetNode?.text || '').substring(0, 40)}
                        </div>`;
                    }).join('')}
                </div>
            `;

            panel.style.display = 'block';
        }

        function highlightNeighborhood(node) {
            const neighborIds = new Set([node.id]);

            // Get all nodes connected to this one
            links.forEach(l => {
                const sourceId = l.source.id || l.source;
                const targetId = l.target.id || l.target;

                if (sourceId === node.id) neighborIds.add(targetId);
                if (targetId === node.id) neighborIds.add(sourceId);
            });

            // Dim non-neighbors (emojis)
            if (emojiElements) {
                emojiElements.style("opacity", d => neighborIds.has(d.id) ? 1.0 : 0.15);
            }

            // Highlight connecting links, dim others
            linkElements.attr("stroke-opacity", d => {
                const sourceId = d.source.id || d.source;
                const targetId = d.target.id || d.target;
                return (sourceId === node.id || targetId === node.id) ? 0.8 : 0.05;
            });
        }

        function clearHighlight() {
            if (emojiElements) {
                emojiElements.style("opacity", 1.0);
            }
            linkElements.attr("stroke-opacity", d => getLinkOpacity(d));
        }

        function highlightConnectedLinks(node) {
            // Make connected links more visible on hover
            linkElements.attr("stroke-opacity", d => {
                const sourceId = d.source.id || d.source;
                const targetId = d.target.id || d.target;

                // Connected links: full opacity, others: keep original
                if (sourceId === node.id || targetId === node.id) {
                    return 0.9;  // Bright and visible
                } else {
                    return getLinkOpacity(d);  // Keep original
                }
            });
        }

        function unhighlightConnectedLinks() {
            // Restore original link opacity
            linkElements.attr("stroke-opacity", d => getLinkOpacity(d));
        }

        function ticked() {
            linkElements
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            // Position emojis (now the primary node visual)
            if (emojiElements) {
                emojiElements
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            }

            // Position label groups (text + background)
            const labelGroups = g.selectAll("g.label-group");
            if (labelGroups.size() > 0) {
                labelGroups.attr("transform", d => `translate(${d.x},${d.y})`);
            }
        }

        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // ====================================================================
        // Operation Animations
        // ====================================================================

        function animateOperation(operation) {
            if (operation.type === 'entity_traversal') {
                animateTraversal(operation.node_id);
            }
            else if (operation.type === 'hebbian_learning') {
                animateHebbianLearning(operation.link_id);
            }
            else if (operation.type === 'activation_increase') {
                animateActivation(operation.node_id);
            }
        }

        function animateTraversal(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Pulse effect on node
            d3.select(`circle[data-id="${nodeId}"]`)
                .transition().duration(300)
                .attr("r", d => (5 + (d.arousal || 0) * 8) * 1.5)
                .transition().duration(300)
                .attr("r", d => 5 + (d.arousal || 0) * 8);
        }

        function animateHebbianLearning(linkId) {
            // Glow effect on link
            const linkElement = d3.select(`line[data-id="${linkId}"]`);

            linkElement
                .classed("link-active", true)
                .transition().duration(1000)
                .on("end", function() {
                    d3.select(this).classed("link-active", false);
                });
        }

        function animateActivation(nodeId) {
            // Ripple effect
            const node = nodes.find(n => n.id === nodeId);
            if (!node || !node.x || !node.y) return;

            g.append("circle")
                .attr("cx", node.x)
                .attr("cy", node.y)
                .attr("r", 5)
                .attr("fill", "none")
                .attr("stroke", "#4CAF50")
                .attr("stroke-width", 2)
                .transition().duration(1000)
                .attr("r", 30)
                .attr("stroke-opacity", 0)
                .remove();
        }

        // ====================================================================
        // UI Controls
        // ====================================================================

        document.getElementById('graphType').addEventListener('change', updateGraphSelector);
        document.getElementById("graphId").addEventListener("change", connectToGraph);

        document.getElementById('entityView').addEventListener('change', (e) => {
            selectedEntity = e.target.value;

            // Show/hide valence legend
            const legend = document.getElementById('valence-legend');
            if (selectedEntity === 'structural') {
                legend.style.display = 'none';
            } else {
                legend.style.display = 'block';
            }

            updateVisualization();
        });

        document.getElementById('timeRange').addEventListener('input', (e) => {
            timeRange = parseInt(e.target.value);
            const hours = (timeRange / 3600000).toFixed(1);
            document.getElementById('timeRangeValue').textContent =
                hours >= 1 ? `${hours} hour${hours > 1 ? 's' : ''}` :
                `${(timeRange / 60000)} min`;
            updateVisualization();
        });

        document.getElementById('showRecentOnly').addEventListener('change', (e) => {
            showRecentOnly = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            showLabels = e.target.checked;
            updateVisualization();
        });

        // ====================================================================
        // Tooltip
        // ====================================================================

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const nodeType = (d.labels && d.labels[0]) || 'Node';
            const nodeEmoji = NODE_TYPE_EMOJIS[nodeType] || NODE_TYPE_EMOJIS['default'];
            const weight = computeNodeWeight(d);

            let content = `<div class="tooltip-title">${nodeEmoji} ${(d.text || 'Node').substring(0, 50)}</div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">Type:</span>
                <span class="tooltip-value">${nodeType}</span>
            </div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">Weight:</span>
                <span class="tooltip-value">${weight.toFixed(2)}</span>
            </div>`;

            if (d.arousal !== undefined) {
                content += `<div class="tooltip-row">
                    <span class="tooltip-label">Arousal:</span>
                    <span class="tooltip-value">${d.arousal.toFixed(2)}</span>
                </div>`;
            }

            if (d.confidence !== undefined) {
                content += `<div class="tooltip-row">
                    <span class="tooltip-label">Confidence:</span>
                    <span class="tooltip-value">${d.confidence.toFixed(2)}</span>
                </div>`;
            }

            if (d.traversal_count !== undefined) {
                content += `<div class="tooltip-row">
                    <span class="tooltip-label">Traversals:</span>
                    <span class="tooltip-value">${d.traversal_count}</span>
                </div>`;
            }

            if (d.last_entity) {
                content += `<div class="tooltip-row">
                    <span class="tooltip-label">Last Entity:</span>
                    <span class="tooltip-value">${d.last_entity}</span>
                </div>`;
            }

            // Add connected links info
            const inLinks = links.filter(l => (l.target.id || l.target) === d.id);
            const outLinks = links.filter(l => (l.source.id || l.source) === d.id);

            if (inLinks.length > 0 || outLinks.length > 0) {
                content += `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div class="tooltip-title" style="font-size: 12px;">Connected Links (${inLinks.length + outLinks.length})</div>
                </div>`;

                // Show up to 5 links total
                const displayLinks = [...inLinks.slice(0, 3), ...outLinks.slice(0, 3)].slice(0, 5);
                displayLinks.forEach(link => {
                    const linkColor = LINK_TYPE_COLORS[link.type] || '#666';
                    const isIncoming = (link.target.id || link.target) === d.id;
                    const otherNodeId = isIncoming ? (link.source.id || link.source) : (link.target.id || link.target);
                    const otherNode = nodes.find(n => n.id === otherNodeId);
                    const otherText = (otherNode?.text || 'Unknown').substring(0, 30);
                    const arrow = isIncoming ? '‚Üê' : '‚Üí';

                    content += `<div class="tooltip-row" style="font-size: 10px; margin: 3px 0;">
                        <span style="color: ${linkColor};">${arrow} [${link.type}]</span>
                        ${otherText}
                    </div>`;
                });

                if (inLinks.length + outLinks.length > 5) {
                    content += `<div class="tooltip-row" style="font-size: 10px; color: #888;">
                        ... and ${inLinks.length + outLinks.length - 5} more
                    </div>`;
                }
            }

            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function showLinkTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const linkColor = getLinkColor(d);  // Dynamic color

            // Get source and target nodes
            const sourceId = d.source.id || d.source;
            const targetId = d.target.id || d.target;
            const sourceNode = nodes.find(n => n.id === sourceId);
            const targetNode = nodes.find(n => n.id === targetId);

            let content = `<div class="tooltip-title" style="color: ${linkColor};">[${d.type}] Link</div>`;

            content += `<div class="tooltip-row" style="margin: 8px 0;">
                <span>${(sourceNode?.text || 'Unknown').substring(0, 40)}</span>
                <br/>
                <span style="color: ${linkColor}; font-size: 16px;">‚Üì</span>
                <br/>
                <span>${(targetNode?.text || 'Unknown').substring(0, 40)}</span>
            </div>`;

            // Show per-entity valences and emotions if available
            if (d.sub_entity_valences && Object.keys(d.sub_entity_valences).length > 0) {
                content += `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div class="tooltip-title" style="font-size: 12px;">Per-Entity Experience</div>
                </div>`;

                Object.entries(d.sub_entity_valences).forEach(([entityId, valence]) => {
                    const valenceColor = getValenceColor(valence);
                    const valenceLabel = valence > 0.3 ? '(positive)' : valence < -0.3 ? '(negative)' : '(neutral)';

                    content += `<div class="tooltip-row" style="margin: 5px 0;">
                        <span class="tooltip-label">${entityId}:</span>
                        <span class="tooltip-value" style="color: ${valenceColor};">
                            ${valence.toFixed(2)} ${valenceLabel}
                        </span>
                    </div>`;

                    // Show emotions for this entity if available
                    if (d.sub_entity_emotion_vectors && d.sub_entity_emotion_vectors[entityId]) {
                        const emotions = d.sub_entity_emotion_vectors[entityId];
                        const topEmotions = Object.entries(emotions)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(([name, val]) => `${name} (${val.toFixed(2)})`)
                            .join(', ');

                        if (topEmotions) {
                            content += `<div style="font-size: 10px; color: #888; margin-left: 10px; margin-top: 2px;">
                                ${topEmotions}
                            </div>`;
                        }
                    }
                });
            }

            // Show structural properties
            content += `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div class="tooltip-title" style="font-size: 12px;">Structural Properties</div>
            </div>`;

            const structuralProps = ['strength', 'co_activations', 'traversal_count', 'last_traversed'];
            structuralProps.forEach(key => {
                if (d[key] !== undefined && d[key] !== null) {
                    let value = d[key];
                    if (typeof value === 'number') {
                        value = value.toFixed(3);
                    }
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">${key}:</span>
                        <span class="tooltip-value">${value}</span>
                    </div>`;
                }
            });

            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // ====================================================================
        // Stats
        // ====================================================================

        function updateStats(filteredNodes, filteredLinks) {
            const activeNodes = filteredNodes.filter(n =>
                n.last_active && n.last_active > (currentTime - timeRange)
            );

            document.getElementById('nodeCount').textContent = filteredNodes.length;
            document.getElementById('linkCount').textContent = filteredLinks.length;
            document.getElementById('activeNodeCount').textContent = activeNodes.length;
        }

        function updateOperationStats(count) {
            operationCount += count;
            const now = Date.now();
            const elapsed = (now - lastOperationTime) / 1000;

            if (elapsed >= 1) {
                const opsPerSec = (operationCount / elapsed).toFixed(1);
                document.getElementById('opsPerSec').textContent = opsPerSec;
                operationCount = 0;
                lastOperationTime = now;
            }
        }

        // ====================================================================
        // Search Functionality
        // ====================================================================

        // Search box event handler
        document.getElementById('searchBox').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            const resultsDiv = document.getElementById('searchResults');

            if (!query) {
                resultsDiv.innerHTML = '';
                return;
            }

            // Find matching nodes
            const matches = nodes.filter(n =>
                (n.text || '').toLowerCase().includes(query)
            ).slice(0, 10);

            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div style="color: #666; padding: 5px;">No matches</div>';
                return;
            }

            // Render results
            resultsDiv.innerHTML = matches.map(n => `
                <div style="padding: 5px; cursor: pointer; border-bottom: 1px solid #333; color: #ccc;"
                     onmouseover="this.style.background='#2a2a2a'"
                     onmouseout="this.style.background='transparent'"
                     onclick="zoomToNode('${n.id}')">
                    ${(n.text || 'Untitled').substring(0, 50)}
                </div>
            `).join('');
        });

        // Zoom to specific node
        window.zoomToNode = function(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || !node.x || !node.y) {
                console.warn('Node not found or no position:', nodeId);
                return;
            }

            // Calculate transform to center on node
            const transform = d3.zoomIdentity
                .translate(width / 2, (height - 70) / 2)
                .scale(2)
                .translate(-node.x, -node.y);

            // Animate zoom
            svg.transition()
                .duration(750)
                .call(d3.zoom().transform, transform);

            // After zoom completes, select and highlight
            setTimeout(() => {
                selectNode(node);
                highlightNeighborhood(node);

                // Clear search
                document.getElementById('searchBox').value = '';
                document.getElementById('searchResults').innerHTML = '';
            }, 800);
        };

        // ====================================================================
        // Contextual Consciousness Observation (Integrated in Graph)
        // ====================================================================


        // ====================================================================
        // Initialization
        // ====================================================================

        fetchAvailableGraphs();
    </script>
</body>
</html>

<script>
// Auto-connect to first available graph on page load
window.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        const graphId = document.getElementById('graphId').value;
        if (graphId && graphId !== '') {
            console.log('Auto-connecting to:', graphId);
            connectToGraph();
        }
    }, 1000); // Wait for graph list to load
});
</script>
